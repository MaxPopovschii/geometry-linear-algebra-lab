import { useState } from 'react'\nimport { Geometry, Point, Line2D, Line3D, Plane } from '../utils/Geometry'\nimport { Vector } from '../utils/Vector'\n\ntype GeometryOperation = 'point-distance' | 'point-line-2d' | 'point-line-3d' | 'point-plane' | 'triangle-area' | 'tetrahedron-volume' | 'angle-vectors' | 'line-intersection' | 'line-plane-intersection'\n\nconst GeometryCalculator = () => {\n  const [operation, setOperation] = useState<GeometryOperation>('point-distance')\n  const [result, setResult] = useState<string>('')\n  const [error, setError] = useState<string>('')\n  \n  // Points\n  const [point1, setPoint1] = useState<Point>({ x: 0, y: 0, z: 0 })\n  const [point2, setPoint2] = useState<Point>({ x: 3, y: 4, z: 0 })\n  const [point3, setPoint3] = useState<Point>({ x: 6, y: 0, z: 0 })\n  const [point4, setPoint4] = useState<Point>({ x: 0, y: 0, z: 5 })\n  \n  // Lines\n  const [line2D, setLine2D] = useState<Line2D>({\n    point: { x: 0, y: 0 },\n    direction: new Vector([1, 1])\n  })\n  \n  const [line3D, setLine3D] = useState<Line3D>({\n    point: { x: 0, y: 0, z: 0 },\n    direction: new Vector([1, 1, 1])\n  })\n  \n  const [line2_2D, setLine2_2D] = useState<Line2D>({\n    point: { x: 2, y: 0 },\n    direction: new Vector([0, 1])\n  })\n  \n  // Plane\n  const [plane, setPlane] = useState<Plane>({\n    point: { x: 0, y: 0, z: 0 },\n    normal: new Vector([0, 0, 1])\n  })\n  \n  // Vectors for angle calculation\n  const [vector1, setVector1] = useState<number[]>([1, 0, 0])\n  const [vector2, setVector2] = useState<number[]>([0, 1, 0])\n\n  const updatePoint = (pointSetter: React.Dispatch<React.SetStateAction<Point>>, coord: 'x' | 'y' | 'z', value: string) => {\n    const numValue = parseFloat(value) || 0\n    pointSetter(prev => ({ ...prev, [coord]: numValue }))\n  }\n\n  const updateLinePoint = (lineSetter: React.Dispatch<React.SetStateAction<Line2D | Line3D>>, coord: 'x' | 'y' | 'z', value: string) => {\n    const numValue = parseFloat(value) || 0\n    lineSetter(prev => ({ \n      ...prev, \n      point: { ...prev.point, [coord]: numValue }\n    }))\n  }\n\n  const updateLineDirection = (lineSetter: React.Dispatch<React.SetStateAction<Line2D | Line3D>>, index: number, value: string, is3D = false) => {\n    const numValue = parseFloat(value) || 0\n    lineSetter(prev => {\n      const newDirection = [...prev.direction.toArray()]\n      newDirection[index] = numValue\n      return {\n        ...prev,\n        direction: new Vector(newDirection)\n      }\n    })\n  }\n\n  const updateVector = (vectorSetter: React.Dispatch<React.SetStateAction<number[]>>, index: number, value: string) => {\n    const numValue = parseFloat(value) || 0\n    vectorSetter(prev => {\n      const newVector = [...prev]\n      newVector[index] = numValue\n      return newVector\n    })\n  }\n\n  const calculate = () => {\n    try {\n      setError('')\n      let resultText = ''\n\n      switch (operation) {\n        case 'point-distance':\n          const distance = Geometry.distancePoints(point1, point2)\n          resultText = `Distanza tra P1(${point1.x}, ${point1.y}${point1.z !== undefined ? ', ' + point1.z : ''}) e P2(${point2.x}, ${point2.y}${point2.z !== undefined ? ', ' + point2.z : ''}):\\n${distance.toFixed(6)}`\n          break\n        \n        case 'point-line-2d':\n          const dist2D = Geometry.distancePointToLine2D(point1, line2D)\n          resultText = `Distanza da punto P(${point1.x}, ${point1.y}) alla retta 2D:\\n${dist2D.toFixed(6)}`\n          break\n        \n        case 'point-line-3d':\n          const dist3D = Geometry.distancePointToLine3D(point1, line3D)\n          resultText = `Distanza da punto P(${point1.x}, ${point1.y}, ${point1.z}) alla retta 3D:\\n${dist3D.toFixed(6)}`\n          break\n        \n        case 'point-plane':\n          const distPlane = Geometry.distancePointToPlane(point1, plane)\n          resultText = `Distanza da punto P(${point1.x}, ${point1.y}, ${point1.z}) al piano:\\n${distPlane.toFixed(6)}`\n          break\n        \n        case 'triangle-area':\n          const area = Geometry.triangleArea(point1, point2, point3)\n          resultText = `Area del triangolo con vertici:\\nP1(${point1.x}, ${point1.y}${point1.z !== undefined ? ', ' + point1.z : ''})\\nP2(${point2.x}, ${point2.y}${point2.z !== undefined ? ', ' + point2.z : ''})\\nP3(${point3.x}, ${point3.y}${point3.z !== undefined ? ', ' + point3.z : ''})\\n\\nArea = ${area.toFixed(6)}`\n          break\n        \n        case 'tetrahedron-volume':\n          const volume = Geometry.tetrahedronVolume(point1, point2, point3, point4)\n          resultText = `Volume del tetraedro con vertici:\\nP1(${point1.x}, ${point1.y}, ${point1.z})\\nP2(${point2.x}, ${point2.y}, ${point2.z})\\nP3(${point3.x}, ${point3.y}, ${point3.z})\\nP4(${point4.x}, ${point4.y}, ${point4.z})\\n\\nVolume = ${volume.toFixed(6)}`\n          break\n        \n        case 'angle-vectors':\n          const v1 = new Vector(vector1)\n          const v2 = new Vector(vector2)\n          const angleRad = v1.angleTo(v2)\n          const angleDeg = Geometry.angleBetweenVectors(v1, v2)\n          resultText = `Angolo tra vettori:\\nV1 = ${v1.toString()}\\nV2 = ${v2.toString()}\\n\\nAngolo = ${angleRad.toFixed(6)} radianti = ${angleDeg.toFixed(6)}¬∞`\n          break\n        \n        case 'line-intersection':\n          const intersection = Geometry.intersectLines2D(line2D, line2_2D)\n          if (intersection) {\n            resultText = `Intersezione delle rette 2D:\\nPunto di intersezione: (${intersection.x.toFixed(6)}, ${intersection.y.toFixed(6)})`\n          } else {\n            resultText = 'Le rette sono parallele - non si intersecano'\n          }\n          break\n        \n        case 'line-plane-intersection':\n          const intersectionLP = Geometry.intersectLinePlane(line3D, plane)\n          if (intersectionLP) {\n            resultText = `Intersezione retta-piano:\\nPunto di intersezione: (${intersectionLP.x.toFixed(6)}, ${intersectionLP.y.toFixed(6)}, ${intersectionLP.z?.toFixed(6)})`\n          } else {\n            resultText = 'La retta √® parallela al piano - non si intersecano'\n          }\n          break\n        \n        default:\n          throw new Error('Operazione non supportata')\n      }\n\n      setResult(resultText)\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Errore sconosciuto')\n      setResult('')\n    }\n  }\n\n  const renderPointInput = (point: Point, setter: React.Dispatch<React.SetStateAction<Point>>, label: string, include3D = true) => {\n    return (\n      <div className=\"input-group\">\n        <label>{label}</label>\n        <div className=\"input-grid\" style={{ gridTemplateColumns: include3D ? '1fr 1fr 1fr' : '1fr 1fr', gap: '0.5rem' }}>\n          <div>\n            <label style={{ fontSize: '0.8rem' }}>x</label>\n            <input\n              type=\"number\"\n              step=\"any\"\n              value={point.x}\n              onChange={(e) => updatePoint(setter, 'x', e.target.value)}\n            />\n          </div>\n          <div>\n            <label style={{ fontSize: '0.8rem' }}>y</label>\n            <input\n              type=\"number\"\n              step=\"any\"\n              value={point.y}\n              onChange={(e) => updatePoint(setter, 'y', e.target.value)}\n            />\n          </div>\n          {include3D && (\n            <div>\n              <label style={{ fontSize: '0.8rem' }}>z</label>\n              <input\n                type=\"number\"\n                step=\"any\"\n                value={point.z || 0}\n                onChange={(e) => updatePoint(setter, 'z', e.target.value)}\n              />\n            </div>\n          )}\n        </div>\n      </div>\n    )\n  }\n\n  const renderLineInput = (line: Line2D | Line3D, setter: any, label: string, is3D = false) => {\n    return (\n      <div className=\"input-group\">\n        <label>{label}</label>\n        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>\n          <div>\n            <label style={{ fontSize: '0.9rem', marginBottom: '0.5rem' }}>Punto sulla retta</label>\n            <div className=\"input-grid\" style={{ gridTemplateColumns: is3D ? '1fr 1fr 1fr' : '1fr 1fr', gap: '0.3rem' }}>\n              <input type=\"number\" step=\"any\" value={line.point.x} onChange={(e) => updateLinePoint(setter, 'x', e.target.value)} />\n              <input type=\"number\" step=\"any\" value={line.point.y} onChange={(e) => updateLinePoint(setter, 'y', e.target.value)} />\n              {is3D && <input type=\"number\" step=\"any\" value={line.point.z || 0} onChange={(e) => updateLinePoint(setter, 'z', e.target.value)} />}\n            </div>\n          </div>\n          <div>\n            <label style={{ fontSize: '0.9rem', marginBottom: '0.5rem' }}>Vettore direzione</label>\n            <div className=\"input-grid\" style={{ gridTemplateColumns: is3D ? '1fr 1fr 1fr' : '1fr 1fr', gap: '0.3rem' }}>\n              <input type=\"number\" step=\"any\" value={line.direction.get(0)} onChange={(e) => updateLineDirection(setter, 0, e.target.value, is3D)} />\n              <input type=\"number\" step=\"any\" value={line.direction.get(1)} onChange={(e) => updateLineDirection(setter, 1, e.target.value, is3D)} />\n              {is3D && <input type=\"number\" step=\"any\" value={line.direction.get(2)} onChange={(e) => updateLineDirection(setter, 2, e.target.value, is3D)} />}\n            </div>\n          </div>\n        </div>\n      </div>\n    )\n  }\n\n  const renderVectorInput = (vector: number[], setter: React.Dispatch<React.SetStateAction<number[]>>, label: string) => {\n    return (\n      <div className=\"input-group\">\n        <label>{label}</label>\n        <div className=\"input-grid\" style={{ gridTemplateColumns: '1fr 1fr 1fr', gap: '0.5rem' }}>\n          {vector.map((value, index) => (\n            <div key={index}>\n              <label style={{ fontSize: '0.8rem' }}>{['x', 'y', 'z'][index]}</label>\n              <input\n                type=\"number\"\n                step=\"any\"\n                value={value}\n                onChange={(e) => updateVector(setter, index, e.target.value)}\n              />\n            </div>\n          ))}\n        </div>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"calculator-container\">\n      <h2 className=\"calculator-title\">üìê Calcolatore di Geometria</h2>\n      \n      <div className=\"input-group\">\n        <label>Calcolo geometrico</label>\n        <select \n          value={operation} \n          onChange={(e) => setOperation(e.target.value as GeometryOperation)}\n        >\n          <option value=\"point-distance\">Distanza tra punti</option>\n          <option value=\"point-line-2d\">Distanza punto-retta (2D)</option>\n          <option value=\"point-line-3d\">Distanza punto-retta (3D)</option>\n          <option value=\"point-plane\">Distanza punto-piano</option>\n          <option value=\"triangle-area\">Area del triangolo</option>\n          <option value=\"tetrahedron-volume\">Volume del tetraedro</option>\n          <option value=\"angle-vectors\">Angolo tra vettori</option>\n          <option value=\"line-intersection\">Intersezione rette (2D)</option>\n          <option value=\"line-plane-intersection\">Intersezione retta-piano</option>\n        </select>\n      </div>\n\n      {/* Render inputs based on operation */}\n      {operation === 'point-distance' && (\n        <>\n          {renderPointInput(point1, setPoint1, 'Punto 1', true)}\n          {renderPointInput(point2, setPoint2, 'Punto 2', true)}\n        </>\n      )}\n\n      {operation === 'point-line-2d' && (\n        <>\n          {renderPointInput(point1, setPoint1, 'Punto', false)}\n          {renderLineInput(line2D, setLine2D, 'Retta 2D', false)}\n        </>\n      )}\n\n      {operation === 'point-line-3d' && (\n        <>\n          {renderPointInput(point1, setPoint1, 'Punto', true)}\n          {renderLineInput(line3D, setLine3D, 'Retta 3D', true)}\n        </>\n      )}\n\n      {operation === 'point-plane' && (\n        <>\n          {renderPointInput(point1, setPoint1, 'Punto', true)}\n          <div className=\"input-group\">\n            <label>Piano</label>\n            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>\n              <div>\n                <label style={{ fontSize: '0.9rem', marginBottom: '0.5rem' }}>Punto sul piano</label>\n                <div className=\"input-grid\" style={{ gridTemplateColumns: '1fr 1fr 1fr', gap: '0.3rem' }}>\n                  <input type=\"number\" step=\"any\" value={plane.point.x} onChange={(e) => setPlane(p => ({ ...p, point: { ...p.point, x: parseFloat(e.target.value) || 0 } }))} />\n                  <input type=\"number\" step=\"any\" value={plane.point.y} onChange={(e) => setPlane(p => ({ ...p, point: { ...p.point, y: parseFloat(e.target.value) || 0 } }))} />\n                  <input type=\"number\" step=\"any\" value={plane.point.z || 0} onChange={(e) => setPlane(p => ({ ...p, point: { ...p.point, z: parseFloat(e.target.value) || 0 } }))} />\n                </div>\n              </div>\n              <div>\n                <label style={{ fontSize: '0.9rem', marginBottom: '0.5rem' }}>Vettore normale</label>\n                <div className=\"input-grid\" style={{ gridTemplateColumns: '1fr 1fr 1fr', gap: '0.3rem' }}>\n                  <input type=\"number\" step=\"any\" value={plane.normal.get(0)} onChange={(e) => setPlane(p => ({ ...p, normal: new Vector([parseFloat(e.target.value) || 0, p.normal.get(1), p.normal.get(2)]) }))} />\n                  <input type=\"number\" step=\"any\" value={plane.normal.get(1)} onChange={(e) => setPlane(p => ({ ...p, normal: new Vector([p.normal.get(0), parseFloat(e.target.value) || 0, p.normal.get(2)]) }))} />\n                  <input type=\"number\" step=\"any\" value={plane.normal.get(2)} onChange={(e) => setPlane(p => ({ ...p, normal: new Vector([p.normal.get(0), p.normal.get(1), parseFloat(e.target.value) || 0]) }))} />\n                </div>\n              </div>\n            </div>\n          </div>\n        </>\n      )}\n\n      {operation === 'triangle-area' && (\n        <>\n          {renderPointInput(point1, setPoint1, 'Vertice 1', true)}\n          {renderPointInput(point2, setPoint2, 'Vertice 2', true)}\n          {renderPointInput(point3, setPoint3, 'Vertice 3', true)}\n        </>\n      )}\n\n      {operation === 'tetrahedron-volume' && (\n        <>\n          {renderPointInput(point1, setPoint1, 'Vertice 1', true)}\n          {renderPointInput(point2, setPoint2, 'Vertice 2', true)}\n          {renderPointInput(point3, setPoint3, 'Vertice 3', true)}\n          {renderPointInput(point4, setPoint4, 'Vertice 4', true)}\n        </>\n      )}\n\n      {operation === 'angle-vectors' && (\n        <>\n          {renderVectorInput(vector1, setVector1, 'Vettore 1')}\n          {renderVectorInput(vector2, setVector2, 'Vettore 2')}\n        </>\n      )}\n\n      {operation === 'line-intersection' && (\n        <>\n          {renderLineInput(line2D, setLine2D, 'Retta 1', false)}\n          {renderLineInput(line2_2D, setLine2_2D, 'Retta 2', false)}\n        </>\n      )}\n\n      {operation === 'line-plane-intersection' && (\n        <>\n          {renderLineInput(line3D, setLine3D, 'Retta 3D', true)}\n          <div className=\"input-group\">\n            <label>Piano</label>\n            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>\n              <div>\n                <label style={{ fontSize: '0.9rem', marginBottom: '0.5rem' }}>Punto sul piano</label>\n                <div className=\"input-grid\" style={{ gridTemplateColumns: '1fr 1fr 1fr', gap: '0.3rem' }}>\n                  <input type=\"number\" step=\"any\" value={plane.point.x} onChange={(e) => setPlane(p => ({ ...p, point: { ...p.point, x: parseFloat(e.target.value) || 0 } }))} />\n                  <input type=\"number\" step=\"any\" value={plane.point.y} onChange={(e) => setPlane(p => ({ ...p, point: { ...p.point, y: parseFloat(e.target.value) || 0 } }))} />\n                  <input type=\"number\" step=\"any\" value={plane.point.z || 0} onChange={(e) => setPlane(p => ({ ...p, point: { ...p.point, z: parseFloat(e.target.value) || 0 } }))} />\n                </div>\n              </div>\n              <div>\n                <label style={{ fontSize: '0.9rem', marginBottom: '0.5rem' }}>Vettore normale</label>\n                <div className=\"input-grid\" style={{ gridTemplateColumns: '1fr 1fr 1fr', gap: '0.3rem' }}>\n                  <input type=\"number\" step=\"any\" value={plane.normal.get(0)} onChange={(e) => setPlane(p => ({ ...p, normal: new Vector([parseFloat(e.target.value) || 0, p.normal.get(1), p.normal.get(2)]) }))} />\n                  <input type=\"number\" step=\"any\" value={plane.normal.get(1)} onChange={(e) => setPlane(p => ({ ...p, normal: new Vector([p.normal.get(0), parseFloat(e.target.value) || 0, p.normal.get(2)]) }))} />\n                  <input type=\"number\" step=\"any\" value={plane.normal.get(2)} onChange={(e) => setPlane(p => ({ ...p, normal: new Vector([p.normal.get(0), p.normal.get(1), parseFloat(e.target.value) || 0]) }))} />\n                </div>\n              </div>\n            </div>\n          </div>\n        </>\n      )}\n\n      <div className=\"btn-group\">\n        <button className=\"btn btn-primary\" onClick={calculate}>\n          Calcola\n        </button>\n        <button \n          className=\"btn btn-secondary\" \n          onClick={() => {\n            setResult('')\n            setError('')\n          }}\n        >\n          Pulisci\n        </button>\n      </div>\n\n      {error && (\n        <div className=\"error\">\n          <strong>Errore:</strong> {error}\n        </div>\n      )}\n\n      {result && (\n        <div className=\"result-section\">\n          <h3 className=\"result-title\">Risultato</h3>\n          <div className=\"result-vector\">\n            <pre style={{ whiteSpace: 'pre-wrap' }}>{result}</pre>\n          </div>\n        </div>\n      )}\n      \n      <div style={{ marginTop: '2rem', padding: '1rem', background: '#fff3e0', borderRadius: '6px', fontSize: '0.9rem' }}>\n        <h4 style={{ marginBottom: '1rem', color: '#f57c00' }}>üìê Formule Geometriche</h4>\n        <ul style={{ marginLeft: '1rem', lineHeight: '1.6' }}>\n          <li><strong>Distanza punti:</strong> d = ‚àö[(x‚ÇÇ-x‚ÇÅ)¬≤ + (y‚ÇÇ-y‚ÇÅ)¬≤ + (z‚ÇÇ-z‚ÇÅ)¬≤]</li>\n          <li><strong>Area triangolo:</strong> A = ¬Ω|v‚ÇÅ √ó v‚ÇÇ| (prodotto vettoriale)</li>\n          <li><strong>Volume tetraedro:</strong> V = ‚Öô|v‚ÇÅ ¬∑ (v‚ÇÇ √ó v‚ÇÉ)| (prodotto misto)</li>\n          <li><strong>Distanza punto-piano:</strong> d = |ax‚ÇÄ + by‚ÇÄ + cz‚ÇÄ + d|/‚àö(a¬≤ + b¬≤ + c¬≤)</li>\n        </ul>\n      </div>\n    </div>\n  )\n}\n\nexport default GeometryCalculator